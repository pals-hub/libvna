.\"
.\" Electrical Network Parameter Conversion Library
.\" Copyright © 2020 D Scott Guthridge <scott_guthridge@rompromity.net>
.\"
.\" This program is free software: you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published
.\" by the Free Software Foundation, either version 3 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.\" General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <http://www.gnu.org/licenses/>.
.\"
.TH VNAFILE 3 "NOV 2017" GNU
.nh
.SH NAME
vnafile_alloc, vnafile_check, vnafile_fload, vnafile_free, vnafile_fsave, vnafile_get_dprecision, vnafile_get_file_type, vnafile_get_format, vnafile_get_fprecision, vnafile_load, vnafile_save, vnafile_set_dprecision, vnafile_set_file_type, vnafile_set_format, vnafile_set_fprecision \- Load and Save Network Parameter Data
.\"
.SH SYNOPSIS
.B #include <vnafile.h>
.PP
.BI "void vnafile_error_fn_t(const char *" message ", void *" error_arg );
.PP
.BI "vnadata_t *vnafile_alloc(vnafile_error_fn_t *" error_fn ,
.if n \{\
.in +4
.\}
.BI "void *" error_arg );
.if n \{\
.in -4
.\}
.PP
.BI "vnafile_type_t vnafile_get_file_type(const vnafile_t *" vfp );
.PP
.BI "int vnafile_set_file_type(vnafile_t *" vfp ", vnafile_type_t " type );
.PP
.BI "const char *vnafile_get_format(const vnafile_t *" vfp );
.PP
.BI "int vnafile_set_format(vnafile_t *" vfp ", const char *" format );
.PP
.BI "int vnafile_get_fprecision(const vnafile_t *" vfp );
.PP
.BI "int vnafile_set_fprecision(const vnafile_t *" vfp ", int " fprecision );
.PP
.BI "int vnafile_get_dprecision(const vnafile_t *" vfp );
.PP
.BI "int vnafile_set_dprecision(const vnafile_t *" vfp ", int " dprecision );
.PP
.BI "int vnafile_load(vnafile_t *" vfp ", const char *" filename ", "
.BI "vnadata_t *" vdp );
.PP
.BI "int vnafile_fload(vnafile_t *" vfp ", FILE *" fp ,
.BI "const char *" filename ,
.if n \{\
.in +4n
.\}
.BI "vnadata_t *" vdp );
.if n \{\
.in -4n
.\}
.PP
.BI "int vnafile_check(vnafile_t *" vfp ", const char *" filename ,
.if n \{\
.in +4
.\}
.BI "const vnadata_t *" vdp );
.if n \{\
.in -4
.\}
.PP
.BI "int vnafile_save(vnafile_t *" vfp ", const char *" filename ,
.if n \{\
.in +4
.\}
.BI "const vnadata_t *" vdp );
.if n \{\
.in -4
.\}
.PP
.BI "int vnafile_fsave(vnafile_t *" vfp ", FILE *" fp ,
.BI "const char *" filename ,
.if n \{\
.in +4
.\}
.BI "const vnadata_t *" vdp );
.if n \{\
.in -4
.\}
.PP
.BI "void vnafile_free(vnafile_t *" vfp );
.PP
Link with \fI-lvna\fP \fI-lm\fP.
.\"
.SH DESCRIPTION
This library loads and saves vector network analyzer (VNA) parameter
data in Touchstone and native file formats.
.PP
The \fBvnafile_alloc\fP() function must be called first to allocate a
handle object used by the other functions.
The \fIerror_fn\fP argument is a pointer to a function the library calls
with a single line \fImessage\fP (without newline) to report errors.
If given as \s-2NULL\s+2, the library functions set \fIerrno\fP and
return failure but do not print messages; the \fIerror_arg\fP argument
is a pointer to arbitrary user data passed through to the error function.
It can be \s-2NULL\s+2.
.PP
The \fBvnafile_get_file_type\fP() and \fBvnafile_set_file_type\fP()
functions get and set the current file type described by the following
enumeration:
.sp
.in +4n
.nf
.ft CW
typedef enum vnafile_type {
    VNAFILE_AUTO,
    VNAFILE_NATIVE,
    VNAFILE_TOUCHSTONE1,
    VNAFILE_TOUCHSTONE2
} vnafile_type_t;
.ft R
.fi
.in -4n
.sp
The default is \s-2VNAFILE_AUTO\s+2 which causes the load and save functions
to try to automatically intuit the type based on the file extension.
If the file ends with ".s<digit>p", the library assumes Touchstone 1
format; if it ends in ".ts", the library assumes Touchstone 2 format;
otherwise, it assumes native format.
.PP
The \fBvnafile_get_format\fP() and \fBvnafile_set_format\fP() functions
get and set the way VNA parameter data is represented in the file.
The \fIformat\fP parameter is a comma-separated case-insensitive list
of the following specifiers:
.sp
.in +4n
.TS
l l.
S[ri|ma|dB]	scattering parameters
T[ri|ma|dB]	scattering-transfer parameters
Z[ri|ma]	impedance parameters
Y[ri|ma]	admittance parameters
H[ri|ma]	hybrid parameters
G[ri|ma]	inverse-hybrid parameters
A[ri|ma]	ABCD parameters
B[ri|ma]	inverse ABCD parameters
Zin[ri|ma]	impedance looking into each port
PRC	Zin as parallel RC
PRL	Zin as parallel RL
SRC	Zin as series RC
SRL	Zin as series RL
VSWR	voltage standing wave ratio
.TE
.in -4n
.sp
with the following optional coordinate system modifiers:
.sp
.sp
.in +4n
.TS
l l.
ri	real, imaginary
ma	magnitude, agnel
dB	decibels, angle
.TE
.in -4n
.sp
In the Touchstone file formats, only one specifier can be given and it must
be restricted to one of the s, z, y, h or g variants.
If \fBvnafile_set_format\fP() isn't called, the default format is "Sri".
.\"
.PP
The \fBvnafile_get_fprecision\fP(), \fBvnafile_set_fprecision\fP(),
\fBvnafile_get_dprecision\fP(), and \fBvnafile_set_dprecision\fP() functions
get and set the numeric precision in decimal digits for frequency and data
values, respectively, when saving to a file.
If not set, \fIfprecision\fP defaults to 7 digits and \fIdprecision\fP
defaults to 6 digits.
.PP
The \fBvnafile_load\fP() function loads VNA parameter data from
\fIfilename\fP, placing the resulting parameter data into the
\fBvnadata_t\fP object pointed to by \fIvdp\fP (see \fBvnadata\fP(3)),
and updating the parameters in the \fBvnafile_t\fP object to match
what was read from the file.
The \fBvnafile_loadf\fP() function does the same, but uses the
caller-supplied open file pointer \fIfp\fP.
The \fIfilename\fP parameter to \fBvnafile_loadf\fP() is used only for
error messages and may be given as "-" or other string that doesn't
really refer to a file.
.PP
The \fBvnafile_check\fP() tests if the given combination of options and
parameter data are valid for \fBvnafile_save\fP().
In other words, it performs a dry run of save to catch errors early
before actual parameter data has been computed.
Some examples of things it checks are: that the format string is compatible
with Touchstone formats, that a parameter matrix with dimensions other
than 2x2 isn't being converted to one of the two-port formats
(t, g, h, a or b), and that multiple system impedances aren't given in
Touchstone 1 format.
.PP
The \fBvnafile_save\fP() function saves the VNA parameter data given
in \fIvdp\fP to \fIfilename\fP.
The \fBvnafile_savef\fP() function saves the parameter data into the
caller-supplied open file pointer \fIfp\fP.
It uses \fIvnafile\fP for error messages only \- this parameter doesn't
have to refer to an actual file.
.SH "RETURN VALUE"
The \fBvnafile_alloc\fP() function returns a pointer to a \fBvnadata_t\fP
object used by the rest of the functions.
The various get functions return the requested data; they do not return
errors.
The integer-valued functions \fBvnafile_set_file_type\fP(),
\fBvnafile_set_format\fP(), \fBvnafile_set_fprecision\fP(),
\fBvnafile_set_dprecision\fP(), \fBvnafile_load\fP(),
\fBvnafile_loadf\fP(), \fBvnfile_check\fP(), \fBvnafile_save\fP() and
\fBvnafile_savef\fP() return zero on success or set \fBerrno\fP and
return -1 on error.
.SH EXAMPLES
.nf
.ft CW
/*
 * Electrical Network Parameter Formatting Library
 * Copyright © 2020 D Scott Guthridge <scott_guthridge@rompromity.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vnafile.h>

char *progname;

#define R       50.0
#define L       7.95775e-6
#define C       3.1831e-9
#define Z1      50.0
#if 0
#define Z2      75.0
#define Z3      110.0
#else
#define Z2      50.0
#define Z3      50.0
#endif

#define PI      3.14159265358979323846264338327950288419716939937508

#define NROWS           3
#define NCOLUMNS        3
#define NFREQUENCIES    7

static double frequency_vector[] = {
    1.0e+3, 1.0e+4, 1.0e+5, 1.0e+6, 1.0e+7, 1.0e+8, 1.0e+9
};
static double complex z0_vector[] = { Z1, Z2, Z3 };

static void calc_s3x3(vnadata_t *vdp, double r, double l, double c,
        const double complex *z0_vector, int findex, double frequency)
{
    double complex s = 2.0 * PI * I * frequency;
    double complex s11, s12, s13;
    double complex s21, s22, s23;
    double complex s31, s32, s33;
    double complex z1  = z0_vector[0];
    double complex z2  = z0_vector[1];
    double complex z3  = z0_vector[2];
    double complex z1c = conj(z1);
    double complex z2c = conj(z2);
    double complex z3c = conj(z3);

    s11 = (r - z1c + z3 + s*(l + ((r - z1c)*(z2 + z3) + z2*z3)*c +
            l*c*s*(r - z1c + z2))) /
          (r + z1 + z3 + s*(l + ((r + z1)*z2 + (r + z1 + z2)*z3)*c +
            l*c*s*(r + z1 + z2)));
    
    s12 = c*z1*s*(z3 + l*s) /
          (r + z1 + z3 + s*(l + (r + z1)*c*z3 + l*c*s*(r + z1)));

    s13 = (z1 + c*z1*z2*s) /
          (r + z1 + s*(l + (r + z1)*c*z2 + l*c*s*(r + z1 + z2)));

    s21 = c*z2*s*(z3 + l*s) /
          (r + z3 + s*(l + r*c*z2 + (r + z2)*c*z3 + l*c*s*(r + z2)));

    s22 = (r + z1 + z3 + s*(l - (r + z1)*c*z2c + (r + z1 - z2c)*c*z3 +
                l*c*s*(r + z1 - z2c))) /
          (r + z1 + z3 + s*(l + (r + z1)*c*z2 + (r + z1 + z2)*c*z3 +
                l*c*s*(r + z1 + z2)));

    s23 = (r + z1)*c*z2*s /
          (r + z1 + s*(l + (r + z1)*c*z2 + l*c*s*(r + z1 + z2)));
    
    s31 = (z3 + c*z2*z3*s) /
          (r + z3 + s*(l + r*c*z2 + (r + z2)*c*z3 + l*c*s*(r + z2)));

    s32 = (r + z1)*c*z3*s /
          (r + z1 + z3 + s*(l + (r + z1)*c*z3 + l*c*s*(r + z1)));

    s33 = (r + z1 - z3c + s*(l + (r + z1)*c*z2 - (r + z1 + z2)*c*z3c +
                l*c*s*(r + z1 + z2))) /
          (r + z1 + z3 + s*(l + (r + z1)*c*z2 + (r + z1 + z2)*c*z3 +
                l*c*s*(r + z1 + z2)));

    vnadata_set_cell(vdp, findex, 0, 0, s11);
    vnadata_set_cell(vdp, findex, 0, 1, s12);
    vnadata_set_cell(vdp, findex, 0, 2, s13);
    vnadata_set_cell(vdp, findex, 1, 0, s21);
    vnadata_set_cell(vdp, findex, 1, 1, s22);
    vnadata_set_cell(vdp, findex, 1, 2, s23);
    vnadata_set_cell(vdp, findex, 2, 0, s31);
    vnadata_set_cell(vdp, findex, 2, 1, s32);
    vnadata_set_cell(vdp, findex, 2, 2, s33);
}

/*
 * error_fn: error printing function for the library
 *   @message: single line error message without a newline
 *   @error_arg: passed through to the error function (unused here)
 */
static void error_fn(const char *message, void *error_arg)
{
    (void)fprintf(stderr, "example: %s\\n", message);
}

int
main(int argc, char **argv)
{
    vnadata_t *vdp;
    vnafile_t *vfp;

    if ((char *)NULL == (progname = strrchr(argv[0], '/'))) {
        progname = argv[0];
    } else {
        ++progname;
    }
    --argc;
    ++argv;

    vdp = vnadata_alloc_and_init(NFREQUENCIES, NROWS, NCOLUMNS, VPT_S);
    vnadata_set_frequency_vector(vdp, frequency_vector);
    for (int findex = 0; findex < NFREQUENCIES; ++findex) {
        calc_s3x3(vdp, R, L, C, z0_vector, findex, frequency_vector[findex]);
    }
    vnadata_set_z0_vector(vdp, z0_vector);

    vfp = vnafile_alloc(error_fn, NULL);
    if (vfp == NULL) {
        (void)fprintf(stderr, "%s: vnafile_create: %s\\n",
            progname, strerror(errno));
        exit(2);
        /*NOTREACHED*/
    }
    vnafile_set_format(vfp, "Sri");
    if (vnafile_save(vfp, "matrix.out", vdp) == -1) {
        (void)fprintf(stderr, "%s: vnafile_save: %s\\n",
            progname, strerror(errno));
        exit(3);
        /*NOTREACHED*/
    }

    exit(0);
    /*NOTREACHED*/
}
.ft R
.fi
.\"
.SH "SEE ALSO"
.BR vnacal "(3), " vnaconv "(3), " vnadata "(3)"
